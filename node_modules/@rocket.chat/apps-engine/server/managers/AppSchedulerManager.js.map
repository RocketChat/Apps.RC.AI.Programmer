{"version":3,"sources":["src/server/managers/AppSchedulerManager.ts"],"names":[],"mappings":"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","file":"AppSchedulerManager.js","sourcesContent":["import { AppStatus } from '../../definition/AppStatus';\nimport { AppMethod } from '../../definition/metadata';\nimport type { IJobContext, IOnetimeSchedule, IProcessor, IRecurringSchedule } from '../../definition/scheduler';\nimport type { AppManager } from '../AppManager';\nimport type { IInternalSchedulerBridge } from '../bridges/IInternalSchedulerBridge';\nimport type { SchedulerBridge } from '../bridges/SchedulerBridge';\nimport type { AppAccessorManager } from '.';\n\nfunction createProcessorId(jobId: string, appId: string): string {\n    return jobId.includes(`_${appId}`) ? jobId : `${jobId}_${appId}`;\n}\n\nexport class AppSchedulerManager {\n    private readonly bridge: SchedulerBridge;\n\n    private readonly accessors: AppAccessorManager;\n\n    private registeredProcessors: Map<string, { [processorId: string]: IProcessor }>;\n\n    constructor(private readonly manager: AppManager) {\n        this.bridge = this.manager.getBridges().getSchedulerBridge();\n        this.accessors = this.manager.getAccessorManager();\n        this.registeredProcessors = new Map();\n    }\n\n    public async registerProcessors(processors: Array<IProcessor> = [], appId: string): Promise<void | Array<string>> {\n        if (!this.registeredProcessors.get(appId)) {\n            this.registeredProcessors.set(appId, {});\n        }\n\n        return this.bridge.doRegisterProcessors(\n            processors.map((processor) => {\n                const processorId = createProcessorId(processor.id, appId);\n\n                this.registeredProcessors.get(appId)[processorId] = processor;\n\n                return {\n                    id: processorId,\n                    processor: this.wrapProcessor(appId, processorId).bind(this),\n                    startupSetting: processor.startupSetting,\n                };\n            }),\n            appId,\n        );\n    }\n\n    public wrapProcessor(appId: string, processorId: string): IProcessor['processor'] {\n        return async (jobContext: IJobContext) => {\n            const processor = this.registeredProcessors.get(appId)[processorId];\n\n            if (!processor) {\n                throw new Error(`Processor ${processorId} not available`);\n            }\n\n            const app = this.manager.getOneById(appId);\n            const status = app.getStatus();\n            const previousStatus = app.getPreviousStatus();\n\n            const isNotToRunJob = this.isNotToRunJob(status, previousStatus);\n\n            if (isNotToRunJob) {\n                return;\n            }\n\n            const logger = app.setupLogger(AppMethod._JOB_PROCESSOR);\n            logger.debug(`Job processor ${processor.id} is being executed...`);\n\n            try {\n                const codeToRun = `module.exports = processor.processor.apply(null, args)`;\n                await app.getRuntime().runInSandbox(codeToRun, {\n                    processor,\n                    args: [\n                        jobContext,\n                        this.accessors.getReader(appId),\n                        this.accessors.getModifier(appId),\n                        this.accessors.getHttp(appId),\n                        this.accessors.getPersistence(appId),\n                    ],\n                });\n                logger.debug(`Job processor ${processor.id} was sucessfully executed`);\n            } catch (e) {\n                logger.error(e);\n                logger.debug(`Job processor ${processor.id} was unsuccessful`);\n\n                throw e;\n            } finally {\n                await this.manager.getLogStorage().storeEntries(appId, logger);\n            }\n        };\n    }\n\n    public async scheduleOnce(job: IOnetimeSchedule, appId: string): Promise<void | string> {\n        return this.bridge.doScheduleOnce({ ...job, id: createProcessorId(job.id, appId) }, appId);\n    }\n\n    public async scheduleRecurring(job: IRecurringSchedule, appId: string): Promise<void | string> {\n        return this.bridge.doScheduleRecurring({ ...job, id: createProcessorId(job.id, appId) }, appId);\n    }\n\n    public async cancelJob(jobId: string, appId: string): Promise<void> {\n        return this.bridge.doCancelJob(createProcessorId(jobId, appId), appId);\n    }\n\n    public async cancelAllJobs(appId: string): Promise<void> {\n        return this.bridge.doCancelAllJobs(appId);\n    }\n\n    public async cleanUp(appId: string): Promise<void> {\n        (this.bridge as IInternalSchedulerBridge & SchedulerBridge).cancelAllJobs(appId);\n    }\n\n    private isNotToRunJob(status: AppStatus, previousStatus: AppStatus): boolean {\n        const isAppCurrentDisabled = status === AppStatus.DISABLED || status === AppStatus.MANUALLY_DISABLED;\n        const wasAppDisabled = previousStatus === AppStatus.DISABLED || previousStatus === AppStatus.MANUALLY_DISABLED;\n\n        return (status === AppStatus.INITIALIZED && wasAppDisabled) || isAppCurrentDisabled;\n    }\n}\n"]}