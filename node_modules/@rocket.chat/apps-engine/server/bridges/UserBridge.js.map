{"version":3,"sources":["src/server/bridges/UserBridge.ts"],"names":[],"mappings":"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","file":"UserBridge.js","sourcesContent":["import type { IUser, IUserCreationOptions, UserType } from '../../definition/users';\nimport { PermissionDeniedError } from '../errors/PermissionDeniedError';\nimport { AppPermissionManager } from '../managers/AppPermissionManager';\nimport { AppPermissions } from '../permissions/AppPermissions';\nimport { BaseBridge } from './BaseBridge';\n\nexport abstract class UserBridge extends BaseBridge {\n    public async doGetById(id: string, appId: string): Promise<IUser> {\n        if (this.hasReadPermission(appId)) {\n            return this.getById(id, appId);\n        }\n    }\n\n    public async doGetByUsername(username: string, appId: string): Promise<IUser> {\n        if (this.hasReadPermission(appId)) {\n            return this.getByUsername(username, appId);\n        }\n    }\n\n    public async doGetAppUser(appId?: string): Promise<IUser | undefined> {\n        return this.getAppUser(appId);\n    }\n\n    public async doCreate(data: Partial<IUser>, appId: string, options?: IUserCreationOptions): Promise<string> {\n        if (this.hasWritePermission(appId)) {\n            return this.create(data, appId, options || {});\n        }\n    }\n\n    public async doRemove(user: IUser, appId: string): Promise<boolean> {\n        if (this.hasWritePermission(appId)) {\n            return this.remove(user, appId);\n        }\n    }\n\n    public async doUpdate(user: IUser, updates: Partial<IUser>, appId: string): Promise<boolean> {\n        if (this.hasWritePermission(appId)) {\n            return this.update(user, updates, appId);\n        }\n    }\n\n    public async doGetUserUnreadMessageCount(uid: string, appId: string): Promise<number> {\n        if (this.hasReadPermission(appId)) {\n            return this.getUserUnreadMessageCount(uid);\n        }\n    }\n\n    public async doDeleteUsersCreatedByApp(appId: string, type: UserType.BOT | UserType.APP): Promise<boolean> {\n        if (this.hasWritePermission(appId)) {\n            return this.deleteUsersCreatedByApp(appId, type);\n        }\n    }\n\n    public async doDeactivate(userId: IUser['id'], confirmRelinquish: boolean, appId: string): Promise<boolean> {\n        if (this.hasWritePermission(appId)) {\n            return this.deactivate(userId, confirmRelinquish, appId);\n        }\n    }\n\n    protected abstract getById(id: string, appId: string): Promise<IUser>;\n\n    protected abstract getByUsername(username: string, appId: string): Promise<IUser>;\n\n    protected abstract getAppUser(appId?: string): Promise<IUser | undefined>;\n\n    protected abstract getActiveUserCount(): Promise<number>;\n\n    protected abstract getUserUnreadMessageCount(uid: string): Promise<number>;\n\n    /**\n     * Creates a user.\n     * @param data the essential data for creating a user\n     * @param appId the id of the app calling this\n     * @param options options for passing extra data\n     */\n    protected abstract create(data: Partial<IUser>, appId: string, options?: IUserCreationOptions): Promise<string>;\n\n    /**\n     * Remove a user.\n     *\n     * @param user the user object to be removed\n     * @param appId the id of the app executing the call\n     */\n    protected abstract remove(user: IUser, appId: string): Promise<boolean>;\n\n    /**\n     * Updates a user.\n     *\n     * Note: the actual methods used by apps to update\n     * user properties are much more granular, but at a\n     * bridge level we can adopt a more practical approach\n     * since it is only accessible internally by the framework\n     *\n     * @param user the user to be updated\n     * @param updates a map of properties to be updated\n     * @param appId the id of the app executing the call\n     */\n    protected abstract update(user: IUser, updates: Partial<IUser>, appId: string): Promise<boolean>;\n\n    /**\n     * Deletes all bot or app users created by the App.\n     * @param appId the App's ID.\n     * @param type the type of the user to be deleted.\n     * @returns true if any user was deleted, false otherwise.\n     */\n    protected abstract deleteUsersCreatedByApp(appId: string, type: UserType.APP | UserType.BOT): Promise<boolean>;\n\n    /**\n     * Deactivates a user.\n     * @param userId the user's ID.\n     * @param confirmRelinquish whether the user confirmed the relinquish of the account.\n     * @param appId the App's ID.\n     * @returns true if the user was deactivated, false otherwise.\n     * @throws {Error} if the user is not found.\n     * @throws {Error} if the user is the last admin.\n     * @throws {Error} if the user is the last owner, if confirmRelinquish is false.\n     */\n    protected abstract deactivate(userId: IUser['id'], confirmRelinquish: boolean, appId: string): Promise<boolean>;\n\n    private hasReadPermission(appId: string): boolean {\n        if (AppPermissionManager.hasPermission(appId, AppPermissions.user.read)) {\n            return true;\n        }\n\n        AppPermissionManager.notifyAboutError(\n            new PermissionDeniedError({\n                appId,\n                missingPermissions: [AppPermissions.user.read],\n            }),\n        );\n\n        return false;\n    }\n\n    private hasWritePermission(appId: string): boolean {\n        if (AppPermissionManager.hasPermission(appId, AppPermissions.user.write)) {\n            return true;\n        }\n\n        AppPermissionManager.notifyAboutError(\n            new PermissionDeniedError({\n                appId,\n                missingPermissions: [AppPermissions.user.write],\n            }),\n        );\n\n        return false;\n    }\n}\n"]}