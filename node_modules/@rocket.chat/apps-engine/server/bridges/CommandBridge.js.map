{"version":3,"sources":["src/server/bridges/CommandBridge.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,2EAAwE;AACxE,2EAAwE;AACxE,kEAA+D;AAC/D,6CAA0C;AAE1C,MAAsB,aAAc,SAAQ,uBAAU;IACrC,kBAAkB,CAAC,OAAe,EAAE,KAAa;;YAC1D,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;gBAClC,OAAO,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;aAChD;QACL,CAAC;KAAA;IAEY,eAAe,CAAC,OAAe,EAAE,KAAa;;YACvD,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;gBAClC,OAAO,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;aAC7C;QACL,CAAC;KAAA;IAEY,gBAAgB,CAAC,OAAe,EAAE,KAAa;;YACxD,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;gBAClC,OAAO,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;aAC9C;QACL,CAAC;KAAA;IAEY,eAAe,CAAC,OAAsB,EAAE,KAAa;;YAC9D,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;gBAClC,OAAO,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;aAC7C;QACL,CAAC;KAAA;IAEY,iBAAiB,CAAC,OAAsB,EAAE,KAAa;;YAChE,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;gBAClC,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;aAC/C;QACL,CAAC;KAAA;IAEY,mBAAmB,CAAC,OAAe,EAAE,KAAa;;YAC3D,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;gBAClC,OAAO,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;aACjD;QACL,CAAC;KAAA;IA6DO,oBAAoB,CAAC,KAAa;QACtC,IAAI,2CAAoB,CAAC,aAAa,CAAC,KAAK,EAAE,+BAAc,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;YAC3E,OAAO,IAAI,CAAC;SACf;QAED,2CAAoB,CAAC,gBAAgB,CACjC,IAAI,6CAAqB,CAAC;YACtB,KAAK;YACL,kBAAkB,EAAE,CAAC,+BAAc,CAAC,OAAO,CAAC,OAAO,CAAC;SACvD,CAAC,CACL,CAAC;QAEF,OAAO,KAAK,CAAC;IACjB,CAAC;CACJ;AA9GD,sCA8GC","file":"CommandBridge.js","sourcesContent":["import type { ISlashCommand } from '../../definition/slashcommands';\nimport { PermissionDeniedError } from '../errors/PermissionDeniedError';\nimport { AppPermissionManager } from '../managers/AppPermissionManager';\nimport { AppPermissions } from '../permissions/AppPermissions';\nimport { BaseBridge } from './BaseBridge';\n\nexport abstract class CommandBridge extends BaseBridge {\n    public async doDoesCommandExist(command: string, appId: string): Promise<boolean> {\n        if (this.hasDefaultPermission(appId)) {\n            return this.doesCommandExist(command, appId);\n        }\n    }\n\n    public async doEnableCommand(command: string, appId: string): Promise<void> {\n        if (this.hasDefaultPermission(appId)) {\n            return this.enableCommand(command, appId);\n        }\n    }\n\n    public async doDisableCommand(command: string, appId: string): Promise<void> {\n        if (this.hasDefaultPermission(appId)) {\n            return this.disableCommand(command, appId);\n        }\n    }\n\n    public async doModifyCommand(command: ISlashCommand, appId: string): Promise<void> {\n        if (this.hasDefaultPermission(appId)) {\n            return this.modifyCommand(command, appId);\n        }\n    }\n\n    public async doRegisterCommand(command: ISlashCommand, appId: string): Promise<void> {\n        if (this.hasDefaultPermission(appId)) {\n            return this.registerCommand(command, appId);\n        }\n    }\n\n    public async doUnregisterCommand(command: string, appId: string): Promise<void> {\n        if (this.hasDefaultPermission(appId)) {\n            return this.unregisterCommand(command, appId);\n        }\n    }\n\n    /**\n     * Checks if the provided command already exists inside of the\n     * system which is being bridged. This does not check if the app\n     * registered it but it will return whether the supplied command is\n     * already defined by something else or not.\n     *\n     * @param command the command to check if it exists\n     * @param appId the id of the app calling this\n     * @returns whether the command is already in the system\n     */\n    protected abstract doesCommandExist(command: string, appId: string): Promise<boolean>;\n\n    /**\n     * Enables an existing command from the bridged system. The callee\n     * must ensure that the command that's being enabled is defined by\n     * the bridged system and not another App since the bridged system\n     * will not check that.\n     *\n     * @param command the command to enable\n     * @param appId the id of the app calling this\n     */\n    protected abstract enableCommand(command: string, appId: string): Promise<void>;\n\n    /**\n     * Disables an existing command from the bridged system, the callee must\n     * ensure the command disabling is defined by the system and not another\n     * App since the bridged system won't check that.\n     *\n     * @param command the command which to disable\n     * @param appId the id of the app calling this\n     */\n    protected abstract disableCommand(command: string, appId: string): Promise<void>;\n\n    /**\n     * Changes how a system slash command behaves, allows Apps to provide\n     * different executors per system commands.\n     *\n     * @param command the modified slash command\n     * @param appId the id of the app calling this\n     */\n    protected abstract modifyCommand(command: ISlashCommand, appId: string): Promise<void>;\n\n    /**\n     * Registers a command with the system which is being bridged.\n     *\n     * @param command the command to register\n     * @param appId the id of the app calling this\n     * @param toRun the executor which is called when the command is ran\n     */\n    protected abstract registerCommand(command: ISlashCommand, appId: string): Promise<void>;\n\n    /**\n     * Unregisters the provided command from the bridged system.\n     *\n     * @param command the command to unregister\n     * @param appId the id of the app calling this\n     */\n    protected abstract unregisterCommand(command: string, appId: string): Promise<void>;\n\n    private hasDefaultPermission(appId: string): boolean {\n        if (AppPermissionManager.hasPermission(appId, AppPermissions.command.default)) {\n            return true;\n        }\n\n        AppPermissionManager.notifyAboutError(\n            new PermissionDeniedError({\n                appId,\n                missingPermissions: [AppPermissions.command.default],\n            }),\n        );\n\n        return false;\n    }\n}\n"]}